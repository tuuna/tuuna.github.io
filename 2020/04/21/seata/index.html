<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Seata分布式事务框架的流程解析 | 洛文小站</title><meta name=keywords content><meta name=description content="XID：全局事务的唯一标识，由 ip:port:sequence 组成； Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；  业务逻辑是经典的下订单、扣余额、减库存流程。 根据模块划分为三个独立的服务，且分别连接对应的数据库：
 订单：order-server 账户：account-server 库存：storage-server 业务：business-server  项目结构如下图
正常业务:   business发起购买请求
  storage扣减库存
  order创建订单
  account扣减余额
  异常业务： 扣减余额异常
正常流程下 2、3、4 步的数据正常更新全局 commit，异常流程下的数据则由于第 4 步的异常报错全局回滚。
使用流程及解析
 首先创建相应的数据库与数据表     库名 含有的表 作用     db_account account_tbl undo_log 存储用户信息   db_order order_tbl undo_log 订单信息   db_storage storage_tbl undo_log 库存信息    注:上面的每一个库可以存储与不同的机器上面。需要在不同的服务里面配置即可"><meta name=author content="赖杰"><link rel=canonical href=https://tuuna.github.io/2020/04/21/seata/><link href=https://tuuna.github.io/assets/css/stylesheet.min.46b233709fd2c907e04a2d946c05f4e1d6edaf81b562cbfdaf6f11aeaa32248c.css integrity="sha256-RrIzcJ/SyQfgSi2UbAX04dbtr4G1Ysv9r28RrqoyJIw=" rel="preload stylesheet" as=style><link rel=icon href=https://tuuna.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tuuna.github.io/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tuuna.github.io/favicon32x32.png><link rel=apple-touch-icon href=https://tuuna.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tuuna.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Seata分布式事务框架的流程解析"><meta property="og:description" content="XID：全局事务的唯一标识，由 ip:port:sequence 组成； Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；  业务逻辑是经典的下订单、扣余额、减库存流程。 根据模块划分为三个独立的服务，且分别连接对应的数据库：
 订单：order-server 账户：account-server 库存：storage-server 业务：business-server  项目结构如下图
正常业务:   business发起购买请求
  storage扣减库存
  order创建订单
  account扣减余额
  异常业务： 扣减余额异常
正常流程下 2、3、4 步的数据正常更新全局 commit，异常流程下的数据则由于第 4 步的异常报错全局回滚。
使用流程及解析
 首先创建相应的数据库与数据表     库名 含有的表 作用     db_account account_tbl undo_log 存储用户信息   db_order order_tbl undo_log 订单信息   db_storage storage_tbl undo_log 库存信息    注:上面的每一个库可以存储与不同的机器上面。需要在不同的服务里面配置即可"><meta property="og:type" content="article"><meta property="og:url" content="https://tuuna.github.io/2020/04/21/seata/"><meta property="article:published_time" content="2020-04-21T03:55:57+00:00"><meta property="article:modified_time" content="2020-04-21T03:55:57+00:00"><meta property="og:site_name" content="洛文小站"><meta name=twitter:card content="summary"><meta name=twitter:title content="Seata分布式事务框架的流程解析"><meta name=twitter:description content="XID：全局事务的唯一标识，由 ip:port:sequence 组成； Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；  业务逻辑是经典的下订单、扣余额、减库存流程。 根据模块划分为三个独立的服务，且分别连接对应的数据库：
 订单：order-server 账户：account-server 库存：storage-server 业务：business-server  项目结构如下图
正常业务:   business发起购买请求
  storage扣减库存
  order创建订单
  account扣减余额
  异常业务： 扣减余额异常
正常流程下 2、3、4 步的数据正常更新全局 commit，异常流程下的数据则由于第 4 步的异常报错全局回滚。
使用流程及解析
 首先创建相应的数据库与数据表     库名 含有的表 作用     db_account account_tbl undo_log 存储用户信息   db_order order_tbl undo_log 订单信息   db_storage storage_tbl undo_log 库存信息    注:上面的每一个库可以存储与不同的机器上面。需要在不同的服务里面配置即可"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Seata分布式事务框架的流程解析","name":"Seata分布式事务框架的流程解析","description":"XID：全局事务的唯一标识，由 ip:port:sequence 组成； Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource …","keywords":[],"articleBody":" XID：全局事务的唯一标识，由 ip:port:sequence 组成； Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；  业务逻辑是经典的下订单、扣余额、减库存流程。 根据模块划分为三个独立的服务，且分别连接对应的数据库：\n 订单：order-server 账户：account-server 库存：storage-server 业务：business-server  项目结构如下图\n正常业务:   business发起购买请求\n  storage扣减库存\n  order创建订单\n  account扣减余额\n  异常业务： 扣减余额异常\n正常流程下 2、3、4 步的数据正常更新全局 commit，异常流程下的数据则由于第 4 步的异常报错全局回滚。\n使用流程及解析\n 首先创建相应的数据库与数据表     库名 含有的表 作用     db_account account_tbl undo_log 存储用户信息   db_order order_tbl undo_log 订单信息   db_storage storage_tbl undo_log 库存信息    注:上面的每一个库可以存储与不同的机器上面。需要在不同的服务里面配置即可\n 启动TC:  TC是用于协调全局事务和分支事务的，用于驱动commit和rollback\n 启动各个服务：  TM服务是位于business-service中的。\n其中怕purchase使用@GlobalTransactional注解，因此它是作为整个事务的TM。\n其中TM的处理流程的代码位于GlobalTransactionalInterceptor.java\nhandleGlobalTransaction 方法中对 TransactionalTemplate  的 execute 进行了调用，从类名可以看到这是一个标准的模版方法，它定义了 TM 对全局事务处理的标准步骤。\n首先开启全局事务然后执行相应的业务逻辑，如成功则commit、失败则进入相应的处理程序。\n在DefaultGlobalTransaction中\n方法开头处 if (role != GlobalTransactionRole.Launcher) 对 role 的判断有关键的作用，表明当前是全局事务的发起者（Launcher）还是参与者（Participant）。如果在分布式事务的下游系统方法中也加上 @GlobalTransactional 注解，那么它的角色就是 Participant，会忽略后面的 begin 直接 return，而判断是 Launcher 还是 Participant 是根据当前上下文是否已存在 XID 来判断，没有 XID 的就是 Launcher，已经存在 XID的就是 Participant。由此可见，全局事务的创建只能由 Launcher 执行，而一次分布式事务中也只有一个Launcher 存在。\nDefaultTransactionManager 负责 TM 与 TC 通讯，发送 begin、commit、rollback 指令。\n可以看出在最开始的时候TM需要发起一个全局事务的请求。\nTC返回了一个全局事务ID，TM成功的注册了一个全局事务\n全局事务创建后，就开始执行 business.execute()，即业务代码 storageFeignClient.deduct(commodityCode, orderCount) 进入 RM 处理流程，此处的业务逻辑为调用 storage-service 的扣减库存接口。\nRM事务处理流程\nOrderserveice代码\nstorage 的接口和 service 方法并未出现 seata相关的代码和注解，体现了 seata的无侵入。那它是如何加入到这次全局事务中的呢？答案在 ConnectionProxy 中，这也是前面说为什么必须要使用 DataSourceProxy 的原因，通过 DataSourceProxy 才能在业务代码的本地事务提交时，fescar 通过该切入点，向 TC 注册分支事务并发送 RM 的处理结果。\n由于业务代码本身的事务提交被 ConnectionProxy 代理实现，所以在提交本地事务时，实际执行的是ConnectionProxy 的 commit 方法。\n通过日志打印可以看出：\n获取business-service传来的XID\n  绑定XID到当前上下文中\n  执行业务逻辑sql\n  向TC创建本次RM的Netty连接\n  向TC发送分支事务的相关信息\n  获得TC返回的branchId\n  记录Undo Log数据\n  向TC发送本次事务PhaseOne阶段的处理结果\n  从当前上下文中解绑XID\n  其中第 1 步和第 9 步，是在 SeatarHandlerInterceptor 中完成的，该类并不属于 seata，是前面提到的 spring-cloud-alibaba-fescar,它实现了基于 feign、rest 通信时将 xid bind 和 unbind 到当前请求上下文中。到这里 RM 完成了 PhaseOne 阶段的工作，接着看 PhaseTwo 阶段的处理逻辑。\n事务提交 各分支事务执行完成后，TC 对各 RM 的汇报结果进行汇总，给各 RM 发送 commit 或 rollback 的指令\n从日志中可以看出\n RM 收到 commit 通知； 执行 commit 动作； 将 commit 结果发送给 TC，branchStatus 为 PhaseTwo_Committed；  具体看下二阶段 commit 的执行过程，在 AbstractRMHandler 类的 doBranchCommit 方法：\n最终会将 branchCommit 的请求调用到 AsyncWorker 的 branchCommit 方法。AsyncWorker 的处理方式是fescar 架构的一个关键部分，因为大部分事务都是会正常提交的，所以在 PhaseOne 阶段就已经结束了，这样就可以将锁最快的释放。PhaseTwo 阶段接收 commit 的指令后，异步处理即可。将 PhaseTwo 的时间消耗排除在一次分布式事务之外。\n所以对于commit动作的处理，RM只需删除xid、branchId对应的undo_log即可。\n事务回滚 对于rollback场景的触发有两种情况\n 分支事务处理异常，即 ConnectionProxy 中 report(false) 的情况 TM捕获到下游系统上抛的异常，即发起全局事务标有 @GlobalTransactional 注解的方法捕获到的异常。在前面 TransactionalTemplate 类的execute模版方法中，对business.execute()的调用进行了catch，catch后会调用rollback，由TM通知TC对应XID需要回滚事务  TC 汇总后向参与者发送 rollback 指令，RM 在 AbstractRMHandler 类的 doBranchRollback 方法中接收这个rollback 的通知。\n然后将 rollback 请求传递到 DataSourceManager 类的 branchRollback 方法\n库存的rollback第一阶段\n库存的rollback第二阶段\nBusiness中的rollback的日志:\n从日志中也可以看出rollback成功。\n","wordCount":"254","inLanguage":"en","datePublished":"2020-04-21T03:55:57Z","dateModified":"2020-04-21T03:55:57Z","author":{"@type":"Person","name":"赖杰"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tuuna.github.io/2020/04/21/seata/"},"publisher":{"@type":"Organization","name":"洛文小站","logo":{"@type":"ImageObject","url":"https://tuuna.github.io/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://tuuna.github.io accesskey=h><img src=/cloud.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span><span class=lang-switch><span>|</span><ul><li><a href=https://tuuna.github.io/about/ title=About aria-label=About>About</a></li></ul></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://tuuna.github.io/archives/><span>Archive</span></a></li><li><a href=https://tuuna.github.io/tags/><span>Tag</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Seata分布式事务框架的流程解析</h1><div class=post-meta>April 21, 2020&nbsp;·&nbsp;2 min&nbsp;·&nbsp;赖杰</div></header><div class=post-content><ul><li>XID：全局事务的唯一标识，由 ip:port:sequence 组成；</li><li>Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；</li><li>Transaction Manager (TM )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</li><li>Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；</li></ul><p>业务逻辑是经典的下订单、扣余额、减库存流程。 根据模块划分为三个独立的服务，且分别连接对应的数据库：</p><ul><li>订单：order-server</li><li>账户：account-server</li><li>库存：storage-server</li><li>业务：business-server</li></ul><p>项目结构如下图</p><p><img src=/2020/04/1.png alt=img></p><h4 id=正常业务>正常业务:<a hidden class=anchor aria-hidden=true href=#正常业务>#</a></h4><ol><li><p>business发起购买请求</p></li><li><p>storage扣减库存</p></li><li><p>order创建订单</p></li><li><p>account扣减余额</p></li></ol><h4 id=异常业务>异常业务：<a hidden class=anchor aria-hidden=true href=#异常业务>#</a></h4><p><strong>扣减余额异常</strong></p><p>正常流程下 2、3、4 步的数据正常更新全局 commit，异常流程下的数据则由于第 4 步的异常报错全局回滚。</p><p>使用流程及解析</p><ol><li>首先创建相应的数据库与数据表</li></ol><table><thead><tr><th>库名</th><th>含有的表</th><th>作用</th></tr></thead><tbody><tr><td>db_account</td><td>account_tbl undo_log</td><td>存储用户信息</td></tr><tr><td>db_order</td><td>order_tbl undo_log</td><td>订单信息</td></tr><tr><td>db_storage</td><td>storage_tbl undo_log</td><td>库存信息</td></tr></tbody></table><p>注:上面的每一个库可以存储与不同的机器上面。需要在不同的服务里面配置即可</p><ul><li>启动TC:</li></ul><p>TC是用于协调全局事务和分支事务的，用于驱动commit和rollback</p><ul><li>启动各个服务：</li></ul><p><img src=/2020/04/2.png alt=img></p><p>TM服务是位于business-service中的。</p><p><img src=/2020/04/3.png alt=img></p><p>其中怕purchase使用@GlobalTransactional注解，因此它是作为整个事务的TM。</p><p>其中TM的处理流程的代码位于<a href=https://github.com/seata/seata/blob/0807ca56793508f65c6cfbda18b8c956c851526d/spring/src/main/java/io/seata/spring/annotation/GlobalTransactionalInterceptor.java>GlobalTransactionalInterceptor.java</a></p><p><img src=/2020/04/4-1.png alt=img></p><p><code>handleGlobalTransaction</code> 方法中对 <a href=https://github.com/seata/seata/blob/develop/tm/src/main/java/com/alibaba/fescar/tm/api/TransactionalTemplate.java>TransactionalTemplate</a> 的 execute 进行了调用，从类名可以看到这是一个标准的模版方法，它定义了 TM 对全局事务处理的标准步骤。</p><p><img src=/2020/04/5-1.png alt=img></p><p>首先开启全局事务然后执行相应的业务逻辑，如成功则commit、失败则进入相应的处理程序。</p><p>在DefaultGlobalTransaction中</p><p><img src=/2020/04/5.png alt=img></p><p>方法开头处 <code>if (role != GlobalTransactionRole.Launcher)</code> 对 role 的判断有关键的作用，表明当前是全局事务的发起者（Launcher）还是参与者（Participant）。如果在分布式事务的下游系统方法中也加上 <code>@GlobalTransactional</code> 注解，那么它的角色就是 Participant，会忽略后面的 begin 直接 return，而判断是 Launcher 还是 Participant 是根据当前上下文是否已存在 XID 来判断，没有 XID 的就是 Launcher，已经存在 XID的就是 Participant。由此可见，全局事务的创建只能由 Launcher 执行，而一次分布式事务中也只有一个Launcher 存在。</p><p>DefaultTransactionManager 负责 TM 与 TC 通讯，发送 begin、commit、rollback 指令。</p><p><img src=/2020/04/6.png alt=img></p><p><img src=/2020/04/7.png alt=img></p><p>可以看出在最开始的时候TM需要发起一个全局事务的请求。</p><p><img src=/2020/04/8.png alt=img></p><p>TC返回了一个全局事务ID，TM成功的注册了一个全局事务</p><p>全局事务创建后，就开始执行 business.execute()，即业务代码 <code>storageFeignClient.deduct(commodityCode, orderCount)</code> 进入 RM 处理流程，此处的业务逻辑为调用 storage-service 的扣减库存接口。</p><p><img src=/2020/04/9.png alt=img></p><p>RM事务处理流程</p><p>Orderserveice代码</p><p><img src=/2020/04/10.png alt=img></p><p>storage 的接口和 service 方法并未出现 seata相关的代码和注解，体现了 seata的无侵入。那它是如何加入到这次全局事务中的呢？答案在 <a href=https://github.com/seata/seata/blob/develop/rm-datasource/src/main/java/com/alibaba/fescar/rm/datasource/ConnectionProxy.java>ConnectionProxy</a> 中，这也是前面说为什么必须要使用 <code>DataSourceProxy</code> 的原因，通过 DataSourceProxy 才能在业务代码的本地事务提交时，fescar 通过该切入点，向 TC 注册分支事务并发送 RM 的处理结果。</p><p>由于业务代码本身的事务提交被 <code>ConnectionProxy</code> 代理实现，所以在提交本地事务时，实际执行的是ConnectionProxy 的 commit 方法。</p><p><img src=/2020/04/11.png alt=img></p><p><img src=/2020/04/12.png alt=img></p><p>通过日志打印可以看出：</p><p><img src=/2020/04/13.png alt=img></p><p>获取business-service传来的XID</p><p><img src=/2020/04/14.png alt=img></p><ol><li><p>绑定XID到当前上下文中</p></li><li><p>执行业务逻辑sql</p></li><li><p>向TC创建本次RM的Netty连接</p></li><li><p>向TC发送分支事务的相关信息</p></li><li><p>获得TC返回的branchId</p></li><li><p>记录Undo Log数据</p></li><li><p>向TC发送本次事务PhaseOne阶段的处理结果</p></li><li><p>从当前上下文中解绑XID</p></li></ol><p>其中第 1 步和第 9 步，是在 <a href=https://github.com/dongsheep/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-fescar/src/main/java/org/springframework/cloud/alibaba/fescar/web/FescarHandlerInterceptor.java>SeatarHandlerInterceptor</a> 中完成的，该类并不属于 seata，是前面提到的 spring-cloud-alibaba-fescar,它实现了基于 feign、rest 通信时将 xid bind 和 unbind 到当前请求上下文中。到这里 RM 完成了 PhaseOne 阶段的工作，接着看 PhaseTwo 阶段的处理逻辑。</p><h2 id=事务提交>事务提交<a hidden class=anchor aria-hidden=true href=#事务提交>#</a></h2><p>各分支事务执行完成后，TC 对各 RM 的汇报结果进行汇总，给各 RM 发送 commit 或 rollback 的指令</p><p><img src=/2020/04/15.png alt=img></p><p>从日志中可以看出</p><ol><li>RM 收到 commit 通知；</li><li>执行 commit 动作；</li><li>将 commit 结果发送给 TC，branchStatus 为 PhaseTwo_Committed；</li></ol><p>具体看下二阶段 commit 的执行过程，在 <a href=https://github.com/seata/seata/blob/develop/rm/src/main/java/com/alibaba/fescar/rm/AbstractRMHandler.java>AbstractRMHandler</a> 类的 doBranchCommit 方法：</p><p><img src=/2020/04/16.png alt=img></p><p>最终会将 branchCommit 的请求调用到 <a href=https://github.com/seata/seata/blob/develop/rm-datasource/src/main/java/com/alibaba/fescar/rm/datasource/AsyncWorker.java>AsyncWorker</a> 的 branchCommit 方法。AsyncWorker 的处理方式是fescar 架构的一个关键部分，因为大部分事务都是会正常提交的，所以在 PhaseOne 阶段就已经结束了，这样就可以将锁最快的释放。PhaseTwo 阶段接收 commit 的指令后，异步处理即可。将 PhaseTwo 的时间消耗排除在一次分布式事务之外。</p><p>所以对于commit动作的处理，RM只需删除xid、branchId对应的undo_log即可。</p><p><img src=/2020/04/17.png alt=img></p><h2 id=事务回滚>事务回滚<a hidden class=anchor aria-hidden=true href=#事务回滚>#</a></h2><p>对于rollback场景的触发有两种情况</p><ol><li>分支事务处理异常，即 <a href=https://github.com/seata/seata/blob/develop/rm-datasource/src/main/java/com/alibaba/fescar/rm/datasource/ConnectionProxy.java>ConnectionProxy</a> 中 <code>report(false)</code> 的情况</li><li>TM捕获到下游系统上抛的异常，即发起全局事务标有 <code>@GlobalTransactional</code> 注解的方法捕获到的异常。在前面 <a href=https://github.com/seata/seata/blob/develop/tm/src/main/java/com/alibaba/fescar/tm/api/TransactionalTemplate.java>TransactionalTemplate</a> 类的execute模版方法中，对business.execute()的调用进行了catch，catch后会调用rollback，由TM通知TC对应XID需要回滚事务</li></ol><p><img src=/2020/04/18.png alt=img></p><p>TC 汇总后向参与者发送 rollback 指令，RM 在 <a href=https://github.com/seata/seata/blob/develop/rm/src/main/java/com/alibaba/fescar/rm/AbstractRMHandler.java>AbstractRMHandler</a> 类的 doBranchRollback 方法中接收这个rollback 的通知。</p><p><img src=/2020/04/19.png alt=img></p><p>然后将 rollback 请求传递到 <code>DataSourceManager</code> 类的 branchRollback 方法</p><p>库存的rollback第一阶段</p><p><img src=/2020/04/20.png alt=img></p><p>库存的rollback第二阶段</p><p><img src=/2020/04/21.png alt=img></p><p>Business中的rollback的日志:</p><p><img src=/2020/04/22.png alt=img></p><p>从日志中也可以看出rollback成功。</p></div><footer class=post-footer><div style="padding:10px 0;margin:20px auto;width:100%;font-size:16px;text-align:center"><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>打赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=/wechat.jpeg alt="WeChat Pay"></a><p>微信打赏</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=/alipay.jpeg alt=Alipay></a><p>支付宝打赏</p></div></div></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://tuuna.github.io>洛文小站</a></span>
<span>&#183;</span>
<span>备案号 <a href=http://www.beian.miit.gov.cn/ rel="noopener noreferrer">蜀ICP备15022210号-3</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>